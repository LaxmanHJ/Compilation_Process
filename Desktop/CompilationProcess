Compilation -Behind the scenes
What really happens when you run your code

		Source Code(.c)
		      |
		      |
		PreProcessor
		      |
		      |
		    .i(Intermediate file)
		      |
		      |
		Compiler(.i)
		      |
		      |
		      .s(assembly Version)
		Assembler(.s)
		      |
		      |
		.obj/.o(low level machine code)
		      |
		      |
		Linker(.obj)
		      |
		      |
		      .exe(executable file)


Step 1) Pre-processing of source file
	
	The C compilation begins with pre-processing of source file. Pre-processor is a 	small software that accepts C source file and performs below tasks.

	-Remove comments from the source code.
	-Macro expansion.
	-Expansion of included header files.

After pre-processing it generates a temporary file with .i extension. Since, it inserts contents of header files to our source code file. Pre-processor generated file is larger than the original source file

	-#include<stdio.h> is replaced by its contents

Step 2) Compilation of pre-processed file

	In next phase of C compilation the compiler comes in action. It accepts temporary 	pre-processed <file-name>.i file generated by the pre-processor and performs 		following tasks.

	#-Check C program for syntax errors.
		Compile-Time errors(Brush up Compiler design)
		1) Lexical : This includes misspellings of identifiers, keywords or 				operators
		2) Syntactical : missing semicolon or unbalanced parenthesis
		3) Semantical : incompatible value assignment or type mismatches 					between operator and operand
		4) Logical : code not reachable, infinite loop.

	#-Translate the file into intermediate code i.e. in assembly language.
		
	Lexical Analysis(Brush up Compiler design)
		SourceCode
		    |
		    |
		 Lexmes
		    |
		    |
		Lexical Analyser
		    |
		    |
		  Tokens
		    |
		    |
		Syntax Analysis
		    |  |
		    |  Context Free Grammar
		    |  |
		    |   --1)Top-Down Parsing
		    |		-Recursive Descent Parser
		    |			-Backtracking
		    |			-Non Backtracking
		    |				-Predictive Parser
		    |					-LL Parser
		    |	
		    |	2)Bottom-Up Parsing
		    |		-Shift Reduce Parser
		    |			-LR parsing
		    |				-SLR Parser
		    |				-LR Parser
		    |				-LALR Parser
		Semantic Analysis
		    |
		    |
		Logical Analysis	
	
	#-Optionally optimise the translated code for better performance.
		Synthesis Phase(Brush up Compiler design)
			1)Code Optimiser
			2)Code Generator

After compiling it generates an intermediate code in assembly language as <file-name.s> file. It is assembly version of our source code.

Step 3)Assembling of compiled source code
	Moving on to the next phase of compilation. Assembler accepts the compiled source 	code (compilation.s) and translates to low level machine code. After successful 	assembling it generates <file-name.o> (in Linux) or <file-name.obj> (in Windows) f	ile known as object file. In our case it generates the compilation.o file.

	#-This file is encoded in low level machine language.

Step 4)Linking of object files
	Finally, the linker comes in action and performs the final task of compilation 		process. It accepts the intermediate file <file-name.o> generated by the 		assembler. It links all the function calls with their original definition. Which 	means the function printf() gets linked to its original definition.

		#-Linker generates the final executable file (.exe in windows)